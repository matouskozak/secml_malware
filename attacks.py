import argparse
import os
import sys
import magic
import numpy as np
import pandas as pd
from secml.array import CArray
from secml_malware.models.malconv import MalConv
from secml_malware.models.c_classifier_end2end_malware import CClassifierEnd2EndMalware, End2EndModel
from secml_malware.models import CClassifierEmber, CClassifierEnd2EndMalware
from secml_malware.models.c_classifier_sorel_net import CClassifierSorel
from secml_malware.attack.blackbox.c_black_box_format_exploit_evasion import CBlackBoxFormatExploitEvasionProblem
from secml_malware.attack.blackbox.c_black_box_padding_evasion import CBlackBoxPaddingEvasionProblem
from secml_malware.attack.blackbox.c_blackbox_header_problem import CBlackBoxHeaderEvasionProblem
from secml_malware.attack.blackbox.c_blackbox_headerfields_problem import CBlackBoxHeaderFieldsEvasionProblem
from secml_malware.attack.blackbox.c_gamma_evasion import CGammaEvasionProblem
from secml_malware.attack.blackbox.c_gamma_sections_evasion import CGammaSectionsEvasionProblem
from secml_malware.attack.blackbox.c_wrapper_phi import CEmberWrapperPhi, CEnd2EndWrapperPhi, CSorelWrapperPhi
from secml_malware.attack.blackbox.ga.c_base_genetic_engine import CGeneticAlgorithm
from secml_malware.attack.whitebox import CHeaderEvasion, CExtendDOSEvasion, CContentShiftingEvasion, CPaddingEvasion, CKreukEvasion
from secml_malware.attack.whitebox.c_headerfields_evasion import CHeaderFieldsEvasion

def white_box_attack(attack_type, malware_folder, output_folder):

    iterations = 50

    path, dirs, files = next(os.walk(malware_folder), (None, None, []))

    net = MalConv()
    net = CClassifierEnd2EndMalware(net)
    net.load_pretrained_model()

    if attack_type == 'PARTIAL_DOS': 

        attack = CHeaderEvasion(net, random_init=False, iterations=iterations, optimize_all_dos=False)

    elif attack_type == 'FULL_DOS': 

        attack = CHeaderEvasion(net, random_init=False, iterations=iterations, optimize_all_dos=True)

    elif attack_type == 'EXTEND':

        attack = CExtendDOSEvasion(net, pe_header_extension=512, iterations=iterations, random_init=False, chunk_hyper_parameter=256)

    elif attack_type == 'SHIFT':

        attack = CContentShiftingEvasion(net, preferable_extension_amount=1024, iterations=iterations, random_init=False, chunk_hyper_parameter=256)

    elif attack_type == 'PADDING':

        attack = CPaddingEvasion(net, random_init=False, iterations=iterations, how_many=10240)

    elif attack_type == 'FGSM':

        attack = CKreukEvasion(net, how_many_padding_bytes=10240, epsilon=0.1, iterations=iterations, compute_slack=True, is_debug=True)

    else:

        return

    for name in files:
        print(f'FILE: {name}')
        try:
            with open(os.path.join(malware_folder, name), 'rb') as handle:
                bytecode = handle.read()
            x = CArray(End2EndModel.bytes_to_numpy(bytecode, net.get_input_max_length(), net.get_embedding_value(), net.get_is_shifting_values())).atleast_2d()
            y = CArray([1])
            y_pred, adv_score, adv_ds, f_obj = attack.run(x, y)
            if output_folder is not None:
                old_path = os.path.join(malware_folder, name)
                new_path = os.path.join(output_folder, name)
                attack.create_real_sample_from_adv(old_path, adv_ds.X[0, :], new_path)
        except Exception as e:
            print(f'Exception details: {e}')

def black_box_attack(attack_type, malware_folder, goodware_folder, output_folder):

    # int, how many sections inject
    how_many_sections = 100
    # int, how many queries can be sent to the detector, default=50
    query_budget = 500
    # int, how many variants to consider at each iteration, default=10
    population_size = 10
    iterations = query_budget // population_size + 1
    section_to_extract = ['.data']
    # float, the regularization parameter. Used by gamma, default=1e-6
    penalty_regularizer = 0.00001
    # float, the detection threshold to bypass, default=0
    threshold = 0
    # where to save the extracted sections. Used by gamma. None for no caching. default=None
    cache_file = None

    path, dirs, files = next(os.walk(malware_folder), (None, None, []))

    net = MalConv()
    net = CClassifierEnd2EndMalware(net)
    net.load_pretrained_model()
    net = CEnd2EndWrapperPhi(net)

    if attack_type == 'GAMMA_PADDING':
        section_population, what_from_who = CGammaEvasionProblem.create_section_population_from_folder(goodware_folder, how_many_sections, sections_to_extract=section_to_extract, cache_file=cache_file)
        attack = CGammaEvasionProblem(section_population, net, penalty_regularizer=penalty_regularizer, population_size=population_size, iterations=iterations) 
    elif attack_type == 'GAMMA_SECTIONS':
        section_population, what_from_who = CGammaSectionsEvasionProblem.create_section_population_from_folder(goodware_folder, how_many_sections, sections_to_extract=section_to_extract, cache_file=cache_file)
        attack = CGammaSectionsEvasionProblem(section_population, net, penalty_regularizer=penalty_regularizer, population_size=population_size, iterations=iterations)
    else:
        return

    engine = CGeneticAlgorithm(attack)

    for name in files:
        print(f'FILE: {name}')
        try:
            with open(os.path.join(malware_folder, name), 'rb') as handle:
                code = handle.read()
            x = CArray(np.frombuffer(code, dtype=np.uint8)).atleast_2d()
            y = CArray([1])
            y_pred, adv_score, adv_ds, f_obj = engine.run(x, y)
            if output_folder is not None:
                new_path = os.path.join(output_folder, name)
                engine.write_adv_to_file(adv_ds.X[0, :], path=new_path)
        except Exception as e:
            print(f'Exception details: {e}')

#===============================
#knowledge = 'WHITE_BOX'
#attack_type = 'PARTIAL_DOS'
#attack_type = 'FULL_DOS'
#attack_type = 'EXTEND'
#attack_type = 'SHIFT'
#attack_type = 'PADDING'
#attack_type = 'FGSM'
#-------------------------------
#knowledge = 'BLACK_BOX'
#attack_type = 'GAMMA_PADDING'
#attack_type = 'GAMMA_SECTIONS'
#===============================



def parse():
    parser = argparse.ArgumentParser()
    parser.add_argument('--knowledge', type=str, required=True, help="'WHITE_BOX' or 'BLACK_BOX'")
    parser.add_argument('--attack', type=str, required=True, help="if 'WHITE_BOX': 'PARTIAL_DOS', 'FULL_DOS', 'EXTEND', 'SHIFT', 'PADDING', 'FGSM' or if 'BLACK_BOX': 'GAMMA_PADDING', 'GAMMA_SECTIONS'")
    args = parser.parse_args()
    print(f'KNOWLEDGE: {args.knowledge}')
    print(f'TYPE: {args.attack}')
    print('-----------------------------')
    knowledge = args.knowledge
    attack_type = args.attack
    return knowledge, attack_type

knowledge, attack_type = parse()

# [SETUP] Path to the goodware folder
goodware_folder = 'secml_malware/data/goodware_samples/'

# [SETUP] Path to the malware folder or malware file
malware_folder = 'secml_malware/data/malware_samples/'

# [SETUP] Path to the folder where adversarial malware samples are stored
output_folder = 'secml_malware/output/' + str(attack_type) + '_' + str(knowledge)

if goodware_folder is not None and not os.path.isdir(goodware_folder):
    print(f"[ERROR] Path {goodware_folder} does not exists.")
else:
    print("[SUCCESS] Goodware folder successfully loaded")

if malware_folder is not None and not os.path.isdir(malware_folder) and not os.path.isfile(malware_folder):
    print(f"[ERROR] Path {malware_folder} does not exists.")
else:
    print("[SUCCESS] Malware folder successfully loaded")

if output_folder is not None and not os.path.isdir(output_folder):
    os.makedirs(output_folder, exist_ok = True)
    print(f"[SUCCESS] Folder {output_folder} created")
elif os.path.isdir(output_folder):
    print("[SUCCESS] Output folder successfully loaded")
else:
    print(f"[ERROR] Path {output_folder} does not exists and cannot be created.")

if knowledge == 'WHITE_BOX':
    white_box_attack(attack_type, malware_folder, output_folder)
elif knowledge == 'BLACK_BOX':
    black_box_attack(attack_type, malware_folder, goodware_folder, output_folder)

