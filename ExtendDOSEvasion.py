import os
import magic
import numpy as np
from secml.array import CArray

from secml_malware.models.malconv import MalConv
from secml_malware.models.c_classifier_end2end_malware import CClassifierEnd2EndMalware, End2EndModel

net = MalConv()
net = CClassifierEnd2EndMalware(net)
net.load_pretrained_model(path="secml_malware/data/trained/malconv.checkpoint")

from secml_malware.attack.whitebox import CExtendDOSEvasion

folder = "secml_malware/data/malware_samples/test_folder"
output_folder = "secml_malware/output"
#folder = "/home/matous/Documents/CVUT_FIT/DP/diploma-thesis/src/AMG/gym_malware/envs/utils/samples/val/"

X = []
y = []
file_names = []
skip_files = []

for i, f in enumerate(os.listdir(folder)):
    path = os.path.join(folder, f)
    #if 'petya' not in path:
    #    continue
    if "PE32" not in magic.from_file(path):
        continue
    #print(path)

    with open(path, "rb") as file_handle:
        code = file_handle.read()
        
    x = End2EndModel.bytes_to_numpy(code, net.get_input_max_length(), 256, False)
    
    _, confidence = net.predict(CArray(x), True) # Target Classifier (MalConv)
    
    #print(confidence[0, 1].item(), path)
    if confidence[0, 1].item() < 0.5: # Correctly classified -> skip files
        skip_files.append(path)
        continue

    print(f"> Added {f} with confidence {confidence[0,1].item()}")
    X.append(x)
    conf = confidence[1][0].item()
    y.append([1 - conf, conf])
    file_names.append(path)
    
print("Number of files to modifie:", len(file_names))
print("Number of skipped files:", len(skip_files))

# Copy skip_files
for path in skip_files:
    os.system(f"cp {path} {os.path.join(output_folder, f'{os.path.basename(path)}_skip')}")
    
# Run attacks and save files
attack = CExtendDOSEvasion(net)
for i, (sample, label) in enumerate(zip(X, y)):
    y_pred, adv_score, adv_ds, f_obj = attack.run(CArray(sample), CArray(label[1]))

    print(attack.confidences_)
    print(f_obj)
    #with open(file_names[i], 'rb') as f:
    #    print('Original length: ', len(f.read()))
    #print('Adversarial sample length: ', len(real_adv_x))
    
    tag = ""
    if f_obj < 0.5:
        tag = "evasive"
    else:
        tag = "fail"
    
    adv_x = adv_ds.X[0,:]
    real_adv_x = attack.create_real_sample_from_adv(file_names[i], adv_x)
    
    with open( os.path.join(output_folder, f"{os.path.basename(file_names[i])}_{tag}"), 'wb') as outfile:
        outfile.write( real_adv_x )

        

    

